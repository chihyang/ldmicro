
介绍
====

LDmicro为一些PIC16微型芯片和Atmel AVR微型控制器生成本地代码。通常用于这些微型芯片的软件是由汇编、C或BASIC语言编写的。由这些语言编写的程序包含一系列语句。这些语言功能强大，完美适应处理器结构，处理器在内部执行一系列指令。

另一方面，PLC常用“梯形图逻辑”编程。一个简单的程序看起来像这样：

   ||                                                                    ||
   ||    Xbutton1           Tdon           Rchatter           Yred       ||
 1 ||-------]/[---------[TON 1.000 s]-+-------]/[--------------( )-------||
   ||                                 |                                  ||
   ||    Xbutton2           Tdof      |                                  ||
   ||-------]/[---------[TOF 2.000 s]-+                                  ||
   ||                                                                    ||
   ||                                                                    ||
   ||                                                                    ||
   ||    Rchatter            Ton             Tnew           Rchatter     ||
 2 ||-------]/[---------[TON 1.000 s]----[TOF 1.000 s]---------( )-------||
   ||                                                                    ||
   ||                                                                    ||
   ||                                                                    ||
   ||------[END]---------------------------------------------------------||
   ||                                                                    ||
   ||                                                                    ||

(TON是一个接通延时；TOF是一个关断延时；--] [--语句是输入，其行为类似于继电器触点。--( )--语句是输出，其行为类似于继电器线圈。因特网及其他地方有许多关于梯形图逻辑的不错的参考资料；对此配置的详细说明见下。)

一些区别是显而易见的：

    * 程序表现为图形形式，而不是语句的文本列表。很多人都觉得这一开始就更易理解。
    
    * 在最基本的层面上，程序看起来像含有继电器触点(输入)和线圈(输出)的电路图。这对具有电路理论知识的编程者来说十分直观。
    
    * 梯形图逻辑编译器负责决定要在哪里进行何种计算。你不必编写代码以确定何时输出需要根据输入变化或定时器事件重新计算，你也不必指定这些计算进行的顺序；PLC工具为你完成它们。
    
LDmicro将梯形图编译为PIC16或AVR芯片代码。它支持下列处理器：
    * PIC16F877
    * PIC16F628
    * PIC16F876 (未测试)
    * PIC16F88 (未测试)
    * PIC16F819 (未测试)
    * PIC16F887 (未测试)
    * PIC16F886 (未测试)
    * ATmega128
    * ATmega64
    * ATmega162 (未测试)
    * ATmega32 (未测试)
    * ATmega16 (未测试)
    * ATmega8 (未测试)

要支持更多AVR或者PIC16芯片很容易，但我无法对它们进行测试。如果你对某一款有特殊需要请联系我，我会看看自己能做些什么。

使用LDmicro，你可以为你的程序画梯形图。你可以在计算机上实时仿真逻辑过程，确信程序编写无误，将微型控制器的引脚安排为程序的输入输出。编译器输出一个.hex文件，你可以使用任何PIC/AVR编程工具将其写入微型控制器中。

LDmicro被设计为类似大多数商业化的PLC编程系统。而许多方面并非工业标准，有一些例外。仔细阅读每个指令的描述，即使它看起来很熟悉。这份文档假设你有关于梯形图和PLC软件的基本知识(执行循环：读取输入，计算，写输出)。   

其他目标
========

LDmicro也可以生成ANSI C代码。你可以将其用于任何可用C编译器的处理器，但你得负责提供运行平台。这意味着LDmicro只生成一个函数PlcCycle()的源代码。你负责安排每个循环对PlcCycle的调用和PlcCycle调用的I/O(读/写数字输入等)函数。

最后，LDmicro可以为运行梯形图的虚拟机生成独立于处理器的字节码。我已经提供了一个简单的解释器/虚拟机配置实例，它是用移植性良好C语言编写的。只要你能提供自己的虚拟机，这一目标适用于任何平台。如果你需要使用梯形图作为更大程序的“描述性语言”，这可能很有用。请查看示例解释器中的注释获得更多细节。

命令行选项
==========

ldmicro.exe通常不带命令行选项运行。这意味着你可以为程序创建一个快捷方式，或者把它保存到你的桌面并在需要时运行，然后从GUI中进行每一件工作。

如果在命令行中给LDmicro传递一个文件名(如，'ldmicro.exe asd.ld')，那么当'asd.ld'存在时，LDmicro将尝试打开它。这意味着你可以将ldmicro.exe和.ld文件关联，这样你双击.ld文件时，它会自动运行。

如果给LDmicro传递形如'ldmicro.exe /c src.ld dest.hex'的命令行参数，它会尝试编译'src.ld'并将输出保存为`dest.hex'。LDmicro在编译后退出，不论编译成功与否。任何消息都会列印到控制台中。这个模式在通过命令行运行LDmicro时才有效。

基础
====

如果不带参数地运行LDmicro它会以一段空程序启动。如果在命令行中带一个梯形图文件名(xxx.ld)运行LDmicro，它会在启动时加载那个程序。LDmicro为程序使用它的内部格式；它无法从任何其他工具输入梯形图。

如果不加载现有文件，你会得到一个带有空段的程序。你应该向它添加指令；例如你可以添加一些名为'Xnew'的触点(Instructions -> Insert Contacts)。'X'表明触点可能会绑定到一个微型控制器的输入引脚中。在选定一个微型控制器并重命名触点后，你要把它分配给一个引脚。名字的第一个字母表明了对象的类型。例如：

    * Xname -- 绑定到微型控制器的输入引脚
    * Yname -- 绑定到微型控制器的输出引脚
    * Rname -- '内部继电器': 内存中的一位
    * Tname -- 定时器; 接通延时, 关断延时, 或保持型
    * Cname -- 计数器, 累加或递减计数
    * Aname -- 从A/D转换器读入的整数
    * name  -- 一个普通的(整数)变量
    
选择名称的余下部分以描述对象作用，使之在程序中独一无二。在程序中同样的名称代表同一对象。例如，在同一程序中同时有一个名为'Tdelay'的接通延时定时器和关断延时定时器是错误的，因为每个计数器都各需内存。另一方面，在同一程序中同时有一个名为'Tdelay'的保持定时器和一个与之关联的名为'Tdelay'的复位指令是正确的。因为在这种情况下你想让两个指令指代同一个定时器。

变量名可以包含字母，数字和下划线(_)。变量名不能以数字开始。变量名是大小写敏感的。

普通变量指令(MOV, ADD, EQU等)可以作用于任何名称的变量。这意味着它们可以访问定时器和技术累加器。有时这会很有用；例如，你可以检查定时器的计数值是否在某一指定范围内。

变量通常是16位整数。这意味着它们位于-32768和32767之间。变量通常视为有符号数。你可以赋像十进制数(0, 1234, -56)这样的常量，也可以通过单引号括起来的字符赋ASCII字符值('A', 'z')。在使用十进制数的大多数地方，你都可以使用ASCII字符码。

在屏幕的底部有程序中所有对象的列表。这一列表是由程序自动生成的；不需要手动更新它。大多数对象不需要配置。但'Xname'，'Yname'和'Aname'对象必须分配给微型控制器的引脚。首先选择你使用的微型控制器(Setting -> Microcontroller)。然后双击列表中的项目来分配I/O引脚。

你可以通过插入或删除指令来修改程序。程序中的显示的闪烁光标指示了当前选中的指令和当前的插入点。如果光标不闪烁按<Tab>或单击一条指令。现在你可以删除当前指令，或向选中指令的左侧或右侧(串联)，上侧或下侧(并联)插入新指令。一些操作是不允许的。例如，不允许在线圈的右侧插入指令。

程序以一个段开始。你可以通过选择Logic菜单中的Insert Rung Before/After添加更多段。通过在一个段中放置多个平行的子电路也可以达到相同的效果，但使用多个段更清晰。

一旦完成了程序，你可以在仿真器中测试它，之后就可为目标微型控制器将其编译为HEX文件。

仿真
====

要进入仿真模式，选择Simulate -> Simulation Mode或按<Ctrl+M>。在仿真模式下程序显示不同。不再有光标，得电的指令显示为亮红色；未得电的指令显示为灰色。按空格键运行一次PLC循环。要实时连续循环，选择Simulate -> Start Real-Time Simulation，或者按<Ctrl+R>。程序的显示会随着其状态的改变实时更新。

你可以通过双击屏幕底部列表中的输入或双击程序中的'Xname'触点指令来改变其状态。如果你改变输入引脚的状态，那么这一改变会在本次PLC循环结束后显示在程序中。在实时仿真中，这一过程自动进行；在非实时模式，在你按下空格键后发生。

编译为本地代码
==============

最终的目的是生成可以写入微型控制器的.hex文件。首先你必须选择Settings ->Microcontroller菜单下的微型控制器型号(?)。然后为每个I/O引脚分配'Xname'或'Yname'对象。双击屏幕底部列表中的对象名来完成这一操作。在弹出的对话框中你可以从列表中选择一个未使用的引脚。

你必须选择程序运行的循环时间，并为编译器设置微型芯片的时钟速度。这些设置位于Settings -> MCU Parameters...菜单下。通常你不需要改变循环时间；10ms适合于大多数应用。输入你使用的微型控制器晶振(或陶瓷谐振器等)频率并点击okay。

现在你可以从程序生成代码了。选择Compile -> Compile，如果你已经编译过程序并想指定一个不同的文件名，选择Compile -> Compile As...。如果没有错误，LDmicro会生成一个Intel IHEX文件以备写入芯片当中。

使用任意合适的编程软件和硬件将hex文件写入微型控制器中。切记设置配置位(保险(?))！对PIC16处理器，配置位包含在hex文件中，大多数编程软件会对其自动检查。对AVR处理器，你必须手动设置配置位。

指令参考
========

> 常开触点
       Xname           Rname          Yname
    ----] [----     ----] [----    ----] [----
    
    如果流经指令的信号为低电平，输出信号为低电平。如果流经指令的信号为高电平，当且仅当给定的输入引脚、输出引脚或者内部继电器为高电平时，输出信号为高电平。这一指令可以检查输入引脚、输出引脚或内部继电器的状态。
    
> 常闭触点
       Xname           Rname          Yname
    ----]/[----     ----]/[----    ----]/[----
    
    如果流经指令的信号为低电平，输出信号为低电平。如果流经指令的信号为高电平，当且仅当给定的输入引脚、输出引脚或者内部继电器为低电平时，输出信号为高电平。这一指令可以检查输入引脚、输出引脚或内部继电器的状态。这是常开触点的相反项。

> 常开线圈
       Rname           Yname
    ----( )----     ----( )----
    
    如果流经指令的信号为低电平，那么给定的内部继电器或输出引脚重设为低电平。如果流经指令的信号为高电平，那么给定的内部继电器或输出引脚为高电平。将输入值分配给线圈是无意义的。这一指令必须位于程序段的最右侧。
    
> 常闭线圈
       Rname           Yname
    ----(/)----     ----(/)----
    
    如果流经指令的信号为高电平，那么给定的内部继电器或输出引脚重设为低电平。如果流经指令的信号为低电平，那么给定的内部继电器或输出引脚为高电平。将输入值分配给线圈是无意义的。这一指令是常开线圈的相反项，必须位于程序段的最右侧。

> 置位线圈
       Rname           Yname
    ----(S)----     ----(S)----
    
    如果流经指令的信号为高电平，那么给定的内部继电器或输出引脚设为高电平。否则内部继电器或输出引脚状态保持不变。这一指令只用于将项圈的状态从低电平改为高电平，通常和复位线圈联合使用。这一指令必须位于程序段的最右侧。
    
> 复位线圈
       Rname           Yname
    ----(R)----     ----(R)----
    
    如果流经指令的信号为高电平，那么给定的内部继电器或输出引脚设为低电平。否则内部继电器或输出引脚状态保持不变。这一指令只用于将项圈的状态从高电平改为低电平，通常和置位线圈联合使用。这一指令必须位于程序段的最右侧。
    
> 接通延时定时器
         Tdon
    -[TON 1.000 s]-
    
    当流经指令的信号从低电平变为高电平时，输出信号在变为高电平之前保持1.000 s低电平。当流经指令的信号由高电平变为低电平，输出信号立即变为低电平。每次输入信号变为低电平，定时器都会重设；在输出变为高电平之前，输入信号必须连续保持高电平1000毫秒。延时时间可以更改。
    
    'Tname'变量从0开始以扫描次数为单位累加。当计数器数值大于等于给定的延时，TON指令输出为高电平。可以在别处修改计数值，例如使用MOV指令。
	
> 接通延时定时器
         Tdoff
    -[TOF 1.000 s]-
    
    当流经指令的信号从高电平变为低电平时，输出信号在变为低电平之前保持1.000 s高电平。当流经指令的信号由低电平变为高电平，输出信号立即变为高电平。每次输入信号变为低电平，定时器都会重设；在输出变为低电平之前，输入信号必须连续保持低电平1000毫秒。延时时间可以更改。
    
    'Tname'变量从0开始以扫描次数为单位累加。当计数器数值大于等于给定的延时，TON指令(?why not  TOF?)输出为高电平。可以在别处修改计数值，例如使用MOV指令。

> 接通延时定时器
         Trto
    -[TRO 1.000 s]-
    
    该指令跟踪输入信号保持高电平的时间。如果输入信号保持高电平至少持续1.000 s，输出信号为高电平。否则输出为低电平。输入信号不需要连续保持1000毫秒高电平；如果输入保持0.6 s高电平，然后保续2.0 s低电平，然后保持0.4 s低电平，那么输出信号变为高电平。只要输入持续1.000 s以上的高电平，输出变为高电平后会一直保持，即使输入信号变为低电平。因此该定时器必须使用复位指令手动复位。
	
    'Tname'变量从0开始以扫描次数为单位累加。当计数器数值大于等于给定的延时，TON指令(?why not  TOF?)输出为高电平。可以在别处修改计数值，例如使用MOV指令。

> (计数器)复位
        Trto             Citems
    ----{RES}----     ----{RES}----
    
	该指令复位一个定时器或计数器。当输入变为低电平或高电平时，TON或TOF定时器自动复位，所以这些定时器不需要RES指令。RTO定时器和CTU/CTD计数器无法自动复位，所以必须使用RES指令手动复位它们。当输入为高电平，计数器或定时器复位；当输入为低电平，没有任何动作。这一指令必须位于程序段的最右侧。
	
> 一次性上升沿触发器
            _
    --[OSR_/ ]--
	
	这一指令通常输出低电平。如果指令的输入在本次扫描中为高电平，在前一次扫描中为低电平，其输出为高电平。因此在每个输入信号的上升沿它生成一个宽度为扫描周期的脉冲信号。如果你想在信号的上升沿触发一个事件，这一指令很有用。
	
> 一次性下降沿触发器
          _
    --[OSF \_]--
	
	这一指令通常输出低电平。如果指令的输入在本次扫描中为低电平，在前一次扫描中为高电平，其输出为高电平。因此在每个输入信号的下降沿它生成一个宽度为扫描周期的脉冲信号。如果你想在信号的下降沿触发一个事件，这一指令十分有用。