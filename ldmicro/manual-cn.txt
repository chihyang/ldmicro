
介绍
====

LDmicro为一些PIC16微型芯片和Atmel AVR微型控制器生成本地代码。通常用于这些微型芯片的软件是由汇编、C或BASIC语言编写的。由这些语言编写的程序包含一系列语句。这些语言功能强大，完美适应处理器结构，处理器在内部执行一系列指令。

另一方面，PLC常用“梯形图逻辑”编程。一个简单的程序看起来像这样：

   ||                                                                    ||
   ||    Xbutton1           Tdon           Rchatter           Yred       ||
 1 ||-------]/[---------[TON 1.000 s]-+-------]/[--------------( )-------||
   ||                                 |                                  ||
   ||    Xbutton2           Tdof      |                                  ||
   ||-------]/[---------[TOF 2.000 s]-+                                  ||
   ||                                                                    ||
   ||                                                                    ||
   ||                                                                    ||
   ||    Rchatter            Ton             Tnew           Rchatter     ||
 2 ||-------]/[---------[TON 1.000 s]----[TOF 1.000 s]---------( )-------||
   ||                                                                    ||
   ||                                                                    ||
   ||                                                                    ||
   ||------[END]---------------------------------------------------------||
   ||                                                                    ||
   ||                                                                    ||

(TON是一个接通延时；TOF是一个关断延时；--] [--语句是输入，其行为类似于继电器触点。--( )--语句是输出，其行为类似于继电器线圈。因特网及其他地方有许多关于梯形图逻辑的不错的参考资料；对此配置的详细说明见下。)

一些区别是显而易见的：

    * 程序表现为图形形式，而不是语句的文本列表。很多人都觉得这一开始就更易理解。
    
    * 在最基本的层面上，程序看起来像含有继电器触点(输入)和线圈(输出)的电路图。这对具有电路理论知识的编程者来说十分直观。
    
    * 梯形图逻辑编译器负责决定要在哪里进行何种计算。你不必编写代码以确定何时输出需要根据输入变化或定时器事件重新计算，你也不必指定这些计算进行的顺序；PLC工具为你完成它们。
    
LDmicro将梯形图编译为PIC16或AVR芯片代码。它支持下列处理器：
    * PIC16F877
    * PIC16F628
    * PIC16F876 (未测试)
    * PIC16F88 (未测试)
    * PIC16F819 (未测试)
    * PIC16F887 (未测试)
    * PIC16F886 (未测试)
    * ATmega128
    * ATmega64
    * ATmega162 (未测试)
    * ATmega32 (未测试)
    * ATmega16 (未测试)
    * ATmega8 (未测试)

要支持更多AVR或者PIC16芯片很容易，但我无法对它们进行测试。如果你对某一款有特殊需要请联系我，我会看看自己能做些什么。

使用LDmicro，你可以为你的程序画梯形图。你可以在计算机上实时仿真逻辑过程，确信程序编写无误，将微型控制器的引脚安排为程序的输入输出。编译器输出一个.hex文件，你可以使用任何PIC/AVR编程工具将其写入微型控制器中。

LDmicro被设计为类似大多数商业化的PLC编程系统。而许多方面并非工业标准，有一些例外。仔细阅读每个指令的描述，即使它看起来很熟悉。这份文档假设你有关于梯形图和PLC软件的基本知识(执行循环：读取输入，计算，写输出)。   

其他目标
========

LDmicro也可以生成ANSI C代码。你可以将其用于任何可用C编译器的处理器，但你得负责提供运行平台。这意味着LDmicro只生成一个函数PlcCycle()的源代码。你负责安排每个循环对PlcCycle的调用和PlcCycle调用的I/O(读/写数字输入等)函数。

最后，LDmicro可以为运行梯形图的虚拟机生成独立于处理器的字节码。我已经提供了一个简单的解释器/虚拟机配置实例，它是用移植性良好C语言编写的。只要你能提供自己的虚拟机，这一目标适用于任何平台。如果你需要使用梯形图作为更大程序的“描述性语言”，这可能很有用。请查看示例解释器中的注释获得更多细节。

命令行选项
==========

ldmicro.exe通常不带命令行选项运行。这意味着你可以为程序创建一个快捷方式，或者把它保存到你的桌面并在需要时运行，然后从GUI中进行每一件工作。

如果在命令行中给LDmicro传递一个文件名(如，'ldmicro.exe asd.ld')，那么当'asd.ld'存在时，LDmicro将尝试打开它。这意味着你可以将ldmicro.exe和.ld文件关联，这样你双击.ld文件时，它会自动运行。

如果给LDmicro传递形如'ldmicro.exe /c src.ld dest.hex'的命令行参数，它会尝试编译'src.ld'并将输出保存为`dest.hex'。LDmicro在编译后退出，不论编译成功与否。任何消息都会列印到控制台中。这个模式在通过命令行运行LDmicro时才有效。

基础
====

如果不带参数地运行LDmicro它会以一段空程序启动。如果在命令行中带一个梯形图文件名(xxx.ld)运行LDmicro，它会在启动时加载那个程序。LDmicro为程序使用它的内部格式；它无法从任何其他工具输入梯形图。

如果不加载现有文件，你会得到一个带有空段的程序。你应该向它添加指令；例如你可以添加一些名为'Xnew'的触点(Instructions -> Insert Contacts)。'X'表明触点可能会绑定到一个微型控制器的输入引脚中。在选定一个微型控制器并重命名触点后，你要把它分配给一个引脚。名字的第一个字母表明了对象的类型。例如：

    * Xname -- 绑定到微型控制器的输入引脚
    * Yname -- 绑定到微型控制器的输出引脚
    * Rname -- '内部继电器': 内存中的一位
    * Tname -- 定时器; 接通延时, 关断延时, 或保持型
    * Cname -- 计数器, 累加或递减计数
    * Aname -- 从A/D转换器读入的整数
    * name  -- 一个普通的(整数)变量
    
选择名称的余下部分以描述对象作用，使之在程序中独一无二。在程序中同样的名称代表同一对象。例如，在同一程序中同时有一个名为'Tdelay'的接通延时定时器和关断延时定时器是错误的，因为每个计数器都各需内存。另一方面，在同一程序中同时有一个名为'Tdelay'的保持定时器和一个与之关联的名为'Tdelay'的复位指令是正确的。因为在这种情况下你想让两个指令指代同一个定时器。

变量名可以包含字母，数字和下划线(_)。变量名不能以数字开始。变量名是大小写敏感的。

普通变量指令(MOV, ADD, EQU等)可以作用于任何名称的变量。这意味着它们可以访问定时器和技术累加器。有时这会很有用；例如，你可以检查定时器的计数值是否在某一指定范围内。

变量通常是16位整数。这意味着它们位于-32768和32767之间。变量通常视为有符号数。你可以赋像十进制数(0, 1234, -56)这样的常量，也可以通过单引号括起来的字符赋ASCII字符值('A', 'z')。在使用十进制数的大多数地方，你都可以使用ASCII字符码。

在屏幕的底部有程序中所有对象的列表。这一列表是由程序自动生成的；不需要手动更新它。大多数对象不需要配置。但'Xname'，'Yname'和'Aname'对象必须分配给微型控制器的引脚。首先选择你使用的微型控制器(Setting -> Microcontroller)。然后双击列表中的项目来分配I/O引脚。

你可以通过插入或删除指令来修改程序。程序中的显示的闪烁光标指示了当前选中的指令和当前的插入点。如果光标不闪烁按<Tab>或单击一条指令。现在你可以删除当前指令，或向选中指令的左侧或右侧(串联)，上侧或下侧(并联)插入新指令。一些操作是不允许的。例如，不允许在线圈的右侧插入指令。

程序以一个段开始。你可以通过选择Logic菜单中的Insert Rung Before/After添加更多段。通过在一个段中放置多个平行的子电路也可以达到相同的效果，但使用多个段更清晰。

一旦完成了程序，你可以在仿真器中测试它，之后就可为目标微型控制器将其编译为HEX文件。

仿真
====

要进入仿真模式，选择Simulate -> Simulation Mode或按<Ctrl+M>。在仿真模式下程序显示不同。不再有光标，得电的指令显示为亮红色；未得电的指令显示为灰色。按空格键运行一次PLC循环。要实时连续循环，选择Simulate -> Start Real-Time Simulation，或者按<Ctrl+R>。程序的显示会随着其状态的改变实时更新。

你可以通过双击屏幕底部列表中的输入或双击程序中的'Xname'触点指令来改变其状态。如果你改变输入引脚的状态，那么这一改变会在本次PLC循环结束后显示在程序中。在实时仿真中，这一过程自动进行；在非实时模式，在你按下空格键后发生。

编译为本地代码
==============

最终的目的是生成可以写入微型控制器的.hex文件。首先你必须选择Settings ->Microcontroller菜单下的微型控制器型号(?)。然后为每个I/O引脚分配'Xname'或'Yname'对象。双击屏幕底部列表中的对象名来完成这一操作。在弹出的对话框中你可以从列表中选择一个未使用的引脚。

你必须选择程序运行的循环时间，并为编译器设置微型芯片的时钟速度。这些设置位于Settings -> MCU Parameters...菜单下。通常你不需要改变循环时间；10ms适合于大多数应用。输入你使用的微型控制器晶振(或陶瓷谐振器等)频率并点击okay。

现在你可以从程序生成代码了。选择Compile -> Compile，如果你已经编译过程序并想指定一个不同的文件名，选择Compile -> Compile As...。如果没有错误，LDmicro会生成一个Intel IHEX文件以备写入芯片当中。

使用任意合适的编程软件和硬件将hex文件写入微型控制器中。切记设置配置位(保险(?))！对PIC16处理器，配置位包含在hex文件中，大多数编程软件会对其自动检查。对AVR处理器，你必须手动设置配置位。

指令参考
========

> 常开触点
       Xname           Rname          Yname
    ----] [----     ----] [----    ----] [----
    
    如果流经指令的信号为假，输出信号为假。如果流经指令的信号为真，当且仅当给定的输入引脚、输出引脚或者内部继电器为真时，输出信号为真。这一指令可以检查输入引脚、输出引脚或内部继电器的状态。
    
> 常闭触点
       Xname           Rname          Yname
    ----]/[----     ----]/[----    ----]/[----
    
    如果流经指令的信号为假，输出信号为假。如果流经指令的信号为真，当且仅当给定的输入引脚、输出引脚或者内部继电器为假时，输出信号为真。这一指令可以检查输入引脚、输出引脚或内部继电器的状态。这是常开触点的相反项。

> 常开线圈
       Rname           Yname
    ----( )----     ----( )----
    
    如果流经指令的信号为假，那么给定的内部继电器或输出引脚重设为假。如果流经指令的信号为真，那么给定的内部继电器或输出引脚为真。将输入值分配给线圈是无意义的。该指令必须位于程序段的最右侧。
    
> 常闭线圈
       Rname           Yname
    ----(/)----     ----(/)----
    
    如果流经指令的信号为真，那么给定的内部继电器或输出引脚重设为假。如果流经指令的信号为假，那么给定的内部继电器或输出引脚为真。将输入值分配给线圈是无意义的。这一指令是常开线圈的相反项，必须位于程序段的最右侧。

> 置位线圈
       Rname           Yname
    ----(S)----     ----(S)----
    
    如果流经指令的信号为真，那么给定的内部继电器或输出引脚设为真。否则内部继电器或输出引脚状态保持不变。这一指令只用于将项圈的状态从假改为真，通常和复位线圈联合使用。该指令必须位于程序段的最右侧。
    
> 复位线圈
       Rname           Yname
    ----(R)----     ----(R)----
    
    如果流经指令的信号为真，那么给定的内部继电器或输出引脚设为假。否则内部继电器或输出引脚状态保持不变。这一指令只用于将项圈的状态从真改为假，通常和置位线圈联合使用。该指令必须位于程序段的最右侧。
    
> 接通延时定时器
         Tdon
    -[TON 1.000 s]-
    
    当流经指令的信号从假变为真时，输出信号在变为真之前保持1.000 s假。当流经指令的信号由真变为假，输出信号立即变为假。每次输入信号变为假，定时器都会重设；在输出变为真之前，输入信号必须连续保持真1000毫秒。延时时间可以更改。
    
    'Tname'变量从0开始以扫描次数为单位累加。当计数器数值大于等于给定的延时，TON指令输出为真。可以在别处修改计数值，例如使用MOV指令。
	
> 接通延时定时器
         Tdoff
    -[TOF 1.000 s]-
    
    当流经指令的信号从真变为假时，输出信号在变为假之前保持1.000 s真。当流经指令的信号由假变为真，输出信号立即变为真。每次输入信号变为假，定时器都会重设；在输出变为假之前，输入信号必须连续保持假1000毫秒。延时时间可以更改。
    
    'Tname'变量从0开始以扫描次数为单位累加。当计数器数值大于等于给定的延时，TON指令(?why not  TOF?)输出为真。可以在别处修改计数值，例如使用MOV指令。

> 接通延时定时器
         Trto
    -[TRO 1.000 s]-
    
    该指令跟踪输入信号保持真的时间。如果输入信号保持真至少持续1.000 s，输出信号为真。否则输出为假。输入信号不需要连续保持1000毫秒真；如果输入保持0.6 s真，然后保续2.0 s假，然后保持0.4 s假，那么输出信号变为真。只要输入持续1.000 s以上的真，输出变为真后会一直保持，即使输入信号变为假。因此该定时器必须使用复位指令手动复位。
	
    'Tname'变量从0开始以扫描次数为单位累加。当计数器数值大于等于给定的延时，TON指令(?why not  TOF?)输出为真。可以在别处修改计数值，例如使用MOV指令。

> (计数器)复位
        Trto             Citems
    ----{RES}----     ----{RES}----
    
	该指令复位一个定时器或计数器。当输入变为假或真时，TON或TOF定时器自动复位，所以这些定时器不需要RES指令。RTO定时器和CTU/CTD计数器无法自动复位，所以必须使用RES指令手动复位它们。当输入为真，计数器或定时器复位；当输入为假，没有任何动作。该指令必须位于程序段的最右侧。
	
> 一次性上升沿触发器
            _
    --[OSR_/ ]--
	
	这一指令通常输出假。如果指令的输入在本次扫描中为真，在前一次扫描中为假，其输出为真。因此在每个输入信号的上升沿它生成一个宽度为扫描周期的脉冲信号。如果你想在信号的上升沿触发一个事件，这一指令很有用。
	
> 一次性下降沿触发器
          _
    --[OSF \_]--
	
	这一指令通常输出假。如果指令的输入在本次扫描中为假，在前一次扫描中为真，其输出为真。因此在每个输入信号的下降沿它生成一个宽度为扫描周期的脉冲信号。如果你想在信号的下降沿触发一个事件，这一指令十分有用。
	
> 短电路，常开电路
    ----+----+----      ----+     +----
	
	短电路的输出状态总和它的输入状态相同。常开电路的输出状态总是假。这些指令通常用于调试。
	
> 主控继电器
    -{MASTER RLY}-
	
	默认情况下，每个段的入口条件都为真。如果以一个为假的段入口条件执行主控继电器指令，那么随后所有的段入口条件都是假，直至遇到下一个主控继电器指令为止(不管该入口继电器的段入口条件为何)。该指令必须成对使用：一个(有条件地)开启可能无效的区域，一个结束它。
	
> 移动
     {destvar :=  }      {Tret :=     }
	-{ 123     MOV}-    -{ srcvar  MOV}-
	
	当该指令的输入为真时，它使给定的目标变量等于给定的源变量或常量。当指令输入为假时它什么也不做。你可以使用移动指令给任何变量赋值，包括定时器和计数器状态变量，这些变量以字母'T'或'C'开头。例如，将0移动到'Tretentive'相当于该定时器的重设指令(RES)。这一指令必须位于程序段的最右侧。
	
> 算术操作
     {ADD  kay  :=}       {SUB  Ccnt :=}
    -{ 'a' + 10   }-     -{ Ccnt - 10  }-
>	
	 {ADD  kay  :=}       {SUB  Ccnt :=}
    -{ 'a' + 10   }-     -{ Ccnt - 10  }-
	
	当该指令的输入为真时，它使给定的目标变量等于给定的表达式。操作数可以是变量(包括定时器和计数器变量)或常量。这些指令使用16位有符号运算。切记当输入条件为真时每个循环都会计算一次结果。如果递加或递减了一个变量(例如，目标变量也是操作数)你可能并不想如此；通常你可以使用一个边沿触发器以便只在输入条件的上升沿或下降沿进行一次运算。除法会进行截断：8 / 3 = 2。该指令必须位于程序段的最右侧。
	
> 比较
     [var ==]        [var >]        [1 >=]
    -[ var2 ]-      -[ 1   ]-      -[ Ton]-
>	
     [var /=]       [-4 <   ]       [1 <=]
    -[ var2 ]-     -[ vartwo]-     -[ Cup]-
	
	如果这一指令的输入为假，输出为假。如果输入为真，当且仅当给定的条件为真时输出为真。这一指令可用来比较(等于，大于，大于等于，不等于，小于，小于等于)两个变量，或比较一个变量和一个16位有符号常量。
	
> 计数器
        Cname          Cname
    --[CTU >=5]--  --[CTD >=5]--
	
	在每个端输入条件的上升沿(即，段输入条件由假变真)计数器递增(CTU，累加)或递减(CTD，递减)对应的计数值。当计数器的计数值大于等于5，计数器的输出状态为真，否则为假。即使段输入条件为假，段输出状态也可能为真；这仅取决于计数器变量。为了递增或递减同一个计数器，可以给CTU和CTD指令取相同的名字。可用RES指令复位计数器，也可对计数器变量执行对普通变量的操作。
	
> 循环计数器
       Cname
    --[CTU 0:7]--
	
	循环计数器像一般的CTU计数器一样工作，除了到达计数上线时将计数值重设为0。例如，如上所示的计数器将按0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2...计数(?)。将用于变量'Cname'的条件语句和该指令联合使用很有用，你可以将该指令作为一个序列生成器。CTC计数器将段输入条件的上升沿作为时钟触发。该指令必须位于程序段的最右侧。
	
> 移位寄存器
     {SHIFT REG   }
    -{ reg0..3    }-
	
	移位寄存器和一系列变量有关。例如，这一寄存器和变量'reg0'，'reg1'，'reg2'和'reg3'有关。移位寄存器的输入为'reg0'。在段入口条件的上升沿，移位寄存器右移。即执行'reg3 := reg2', 'reg2 := reg1'和reg1 := reg0'。'reg0'保持不变。大型移位寄存器会消耗很多内存。该指令必须位于程序段的最右侧。
	
>  查询表
     {dest :=     }
    -{ LUT[i]     }-
	
	查询表是n个数值的有序集合。当段入口条件为真，整型变量'dest'等于查询表中对应整型变量'i'的项。序号从零开始，所以'i'必须介于0和(n-1)之间。序号超范围时指令的行为未定义。该指令必须位于程序段的最右侧。
	
> 分段线性表
     {yvar :=     }
    -{ PWL[xvar]  }-
	
	该指令很适合拟合复杂函数或曲线。例如，用校准曲线将从传感器得到的原始输入电压转换为更方便的单位。
	
	假定要拟合一个函数将整型输入变量x转换为整型输出变量y。已知函数在某些点的值。例如，可能已知：
	
        f(0)   = 2
        f(5)   = 10
        f(10)  = 50
        f(100) = 100
	
	这相当于曲线经过点
	
        (x0, y0)   = (  0,   2)
        (x1, y1)   = (  5,  10)
        (x2, y2)   = ( 10,  50)
        (x3, y3)   = (100, 100)
	
	你可以将这4个点输入到和分段线性指令相关的表中。分段线性指令将根据xvar的值求取yvar的值，并使分段线性曲线经过你给出的所有点。例如，如果你设置xvar = 10，那么该指令求得yvar = 50。
	
	如果你给出的xvar的值介于两个给定点的x之间，该指令求得yavr以使(xvar, yvar)位于连接表中这两点的直线上。例如，从xvar = 55得到yvar = 75。(表中的两个点是(10, 50)和(100, 100)，55是10和100的平均数，75是50和100的平均数，因此(55, 75)位于连接这两点的直线上。)
	
	点必须按照x坐标升序排列。对某些使用16位整数的查询表可能无法执行必须的数学运算；在这种情况下，LDmicro会给出警告。例如，下列查询表会产生一个错误：
	
        (x0, y0)    = (  0,   0)
        (x1, y1)    = (300, 300)

	你可以通过减小表中两点之间的距离来修正这一错误。例如，下列表和上述等价，且不会产生错误：

        (x0, y0)    = (  0,   0)
        (x1, y1)    = (150, 150)
        (x2, y2)    = (300, 300)
	
	很少情况需要用到超过五六个点。添加点会使代码量增大，执行减慢。传给指令的'xvar'大于表中横坐标上限或小于横坐标下限时，指令的行为未定义。该指令必须位于程序段的最右侧。
	
> A/D 转换器读取
        Aname
    --{READ ADC}--
	
	